<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Achievement Unlocked - A Better Path to Language Learning</title>

    <meta name="description" content="Turning the process of learning new programming languages into an addictive game: make-a-lisp">
    <meta name="author" content="Joel Martin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Achievement Unlocked</h1>
          <h3>A Better Path to Language Learning</h3>
          <p>Midwest.io 2015</p>
          <p>Joel Martin</p>
          <aside class="notes">
            <ul>
              <li>Have sized window for mal demo open
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">guide</a>
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step0">step0 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step1">step1 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step2">step2 image</a> in presentation window for quick tabbing.
            </ul>
          </aside>
        </section>

        <section>
          <h2>About Me</h2>
          <p>Joel Martin (kanaka)</a></p>
          <p><a href="https://github.com/kanaka">github.com/kanaka</a></p>
          <p><a href="http://twitter.com/buskanaka">@buskanaka</a></p>
          <p>Principal Software Engineer at ViaSat, Inc</p>
          <p class="fragment">Clojure</p>
          <p class="fragment">Satellites!</p>
          <aside class="notes">
            <ul>
                <li>My name is Joel Martin
                <li>Principal Software Engineer at ViaSat, Inc
                <li>Basically I get to write Clojure, work with some
                amazing people, and work at a company that does
                broadband Internet from space.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Welcome to Polyglossia</h2>
          <ul class="fragment" data-fragment-index="1">
            <li>Groovy (2003)
            <li>Scala (2003)
            <li>Go (2009)
            <li>Swift (2014)
          </ul>
          <ul class="fragment" data-fragment-index="2">
            <li>Clojure (2003)
            <li>Rust (2003)
            <li>Dart (2009)
            <li>Factor (2014)
          </ul>
          <ul class="fragment" data-fragment-index="3">
            <li>Factor (2003)
            <li>Nim (2008)
            <li>Kotlin (2011)
            <li>Crystal (2012)
          </ul>
          <div style="margin-left: 5em;">
          <p class="fragment" data-fragment-index="4" style="text-align: left;">
            The Best Language<font color="#ffea9a" class="fragment" data-fragment-index="6">s</font>
            for the &nbsp;
            <span style="position: relative; color: #ffea9a;">
              <span class="fragment fade-in" data-fragment-index="4" style="position: absolute;">
                <span class="fragment fade-out" data-fragment-index="5">
                Company/Organization
                </span>
              </span>
              <span class="fragment fade-in" data-fragment-index="5" style="position: absolute;">
                <span class="fragment fade-out" data-fragment-index="6">
                Task/Project
                </span>
              </span>
              <span class="fragment fade-in" data-fragment-index="6" style="position: absolute;">
                System
              </span>
            </span>
          </p>
          </div>
          <p class="fragment" data-fragment-index="7">
            It's a Polyglot World
          </p>
          <aside class="notes">
            <p>
              Show of hands: how many of you have written non-trivial
              code in more than one programming language over the past:
            </p>
            <ul>
                <li>- year?
                <li>- month?
                <li>- week?
                <li>- today?
            </ul>
            <p>The rate of language creation isn't slowing down.</p>
            <p>Hidden 1 [First Set]: I suspect almost everybody here
            has heard of these</p>
            <p>Hidden 2 [Second Set]: There is a good chance you've
            heard of these.</p>
            <p>Hidden 3 [Third Set]: But you not have heard of these.
            But in fact these are all really interesting languages and
            you should look them up (after this talk of course).</p>
            <p>Hidden 4: "It's a PolyGlot World"</p>
          </aside>
        </section>

<!--
        <section>
          <h2>Growing Profusion</h2>
          <p class="fragment">
            ... and Growing Confusion
          </p>
          <ul class="fragment">
            <li>Groovy (2003)
            <li>Scala (2003)
            <li>Go (2009)
            <li>Swift (2014)
          </ul>
          <ul class="fragment">
            <li>Clojure (2003)
            <li>Rust (2003)
            <li>Dart (2009)
            <li>Factor (2014)
          </ul>
          <ul class="fragment">
            <li>Factor (2003)
            <li>Nim (2008)
            <li>Kotlin (2011)
            <li>Crystal (2012)
          </ul>
          <aside class="notes">
            <p>The rate of language creation isn't slowing down.</p>
            <p>Hidden 1 [First Set]: I suspect almost everybody here
            has heard of these</p>
            <p>Hidden 2 [Second Set]: There is a good chance you've
            heard of these.</p>
            <p>Hidden 3 [Third Set]: But you not have heard of these.
            But in fact these are all really interesting languages and
            you should look them up (after this talk of course).</p>
          </aside>
        </section>

        <section>
          <h2>The Name of the Game</h2>
          <ul>
              <li>The Best Language for the Company/Organization
              <li class="fragment">The Best Language for the Task/Project
              <li class="fragment">The Best Language<font color="red">s</font> for the System
              <ul>
                  <li class="fragment">APIs
                  <li class="fragment">Interop
                  <ul class="fragment">
                      <li>FFI
                      <li>Language Virtual Machines (JVM, CLR)
                  </ul>
                  <li class="fragment">Common Compilation Targets (Transpilers)
              </ul>
              <li class="fragment">Single language jobs/projects are
              a dying breed.
              <li class="fragment">You must become Polygot to succeed.
          </ul>
          <aside class="notes">
            <p>Hidden [Interop]: Groovy, Scala, Clojure, Kotlin all run
            on the JVM and can call into code written in the other
            language</p>
            <p>Hidden [Transpile]: Everything compiles to JavaScript
            these days</p>
            <p>For a new language to be successful, it must find
            a point of leverage</p>
          </aside>
        </section>
-->

        <section>
          <h2>Learning is work!</h2>
          <h2 class="fragment">Work is inherently difficult</h2>
          <aside class="notes">
            Most popular languages have a wealth of learning
            resources.  Many even have step-by-step incremental
            tutorials to help you learn the language.] - [But learning
            a new language is still a lot of work. The best learning
            resources are like reading quirky books (e.g.  "Learn you
            a Haskell for Great Good" and "Why's Poignant Guide to
            Ruby"), but they are still mentally tiring.  But most
            language learning resources feel more like this:
          </aside>
        </section>

        <section>
          <h2>... or is it?</h2>
          <blockquote class="fragment" cite="Game of Work - Coonradt, Ch. 1">
            &ldquo;Why will people pay for the privilege of working
            harder than they will work when they are paid?<br>
            -- The Game of Work: Charles Coonradt&rdquo;
          </blockquote>
          <p class="fragment">"Work" is not a thing, it's a state of mind.</p>
          <aside class="notes">
            <p>Meat packers might act like they have the job from
            hell, but then those same people might gladly pay to go
            hunting in the dead of winter.</p>
            <p>The same people who have trouble pulling themselves out
            of bed a 7AM to go to work in their air conditioned
            office, will happily wake up at 4AM to go hunting in
            frigid snow.</p>
            <p></p>
          </aside>
        </section>

        <section>
          <h2>The Inspiration</h2>
          <ul>
              <li class="fragment" data-fragment-index="1">Gherkin<br>
              <li class="fragment" data-fragment-index="3">lispy</li>
              <span class="fragment fade-in" data-fragment-index="2">
                <span class="fragment fade-out" data-fragment-index="3">
                  <img src="media/surprised-baby.gif"></img>
                </span>
              </span>
          </ul>
          <aside class="notes">
            <ul>
                <li>I'm going to tell you a personal story about
                language learning.
                <li>
                    <ul>
                        <li>Way back in 2013, Alan Dipert presented this at Clojure/conj
                        <li>A Lisp implemented in bash [show mindblown]
                        <li>Raised the question for me: what other
                        non-traditional language could a Lisp be implemented
                        in?
                        <li>Had particular language in mind. As far as I knew,
                        no one had ever written a Lisp using it. You'll see
                        why in a moment.
                    </ul>
                <li>Lispy: a small and simple Python implementation of
                a Lisp interpreter by Peter Norvig. I used that as
                a model.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal Beginnings</h2>
          </section>

          <section>
            <h2>JS</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
function read_form(reader) {
    var token = reader.peek();
    switch (token) {
    // reader macros/transforms
    case ';': return null; // Ignore comments
    case '\'': reader.next();
               return [types._symbol('quote'), read_form(reader)];
    case '`': reader.next();
              return [types._symbol('quasiquote'), read_form(reader)];
    case '~': reader.next();
              return [types._symbol('unquote'), read_form(reader)];
...
            </code></pre>
            <aside class="notes">
              First did an implementation in JS to make sure
              I understood the process well. I had not made a Lisp
              from scratch before.
            </aside>
          </section>
          <section>
            <h2 class="fragment" data-fragment-index="1">GNU Make</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
define READ_FORM
$(and $(READER_DEBUG),$(info READ_FORM: $($(1))))
$(call READ_SPACES,$(1))
$(foreach ch,$(word 1,$($(1))),\
  $(if $(filter $(SEMI),$(ch)),\
    $(call DROP_UNTIL,$(1),$(_NL)),\
  $(if $(filter $(SQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(QQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quasiquote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(UNQUOTE),$(ch)),\
...
            </code></pre>
            <p class="fragment" class="fragment" data-fragment-index="2">"<font color="green">Ma</font>ke <font color="green">L</font>isp"
            <aside class="notes">
              <ul>
                <li>Here is a sample of the code from the target
                language that I was inspired to write a Lisp in.
                Anybody willing to guess what language this example
                code is written in?
                <li>GNU Make. And yes, it's really does work and it's
                a full implementation.
                <li>Demo
                <pre style="background: #aaa;">
cd make
./mal.mk ../mal/hello.js
cat ../mal/hello.js</pre>
                <li>The name "Mal" original "MAke Lisp" because that
                was all I was really originally intenteding to do. But
                then I had the thought...
              </ul>
          </section>
          <section>
            <h2>Bash</h2>
            <pre><code class="bash" data-trim contenteditable>
...
READ_FORM () {
  local token=${__reader_tokens[${__reader_idx}]}
  case "${token}" in
    \')   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
    \`)   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quasiquote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>My JS and Make Lisp interpreters had a fairly
                different structure compared to Gherkin. So I decided
                to try my hand at Bash.
                <li>Began to see patterns. Started thinking in terms
                of small digestable chunks, partly just due to the
                fact my job and life meant I only had short segments
                of time to work on it.
              </ul>
            </aside>
          </section>
          <section>
            <h2>C</h2>
            <pre><code class="c" data-trim contenteditable>
...
MalVal *read_form(Reader *reader) {
    char *token;
    MalVal *form = NULL, *tmp;
    token = reader_peek(reader);
    if (!token) { return NULL; }
    switch (token[0]) {
    case ';':
        abort("comments not yet implemented");
        break;
    case '\'':
        reader_next(reader);
        form = _listX(2, malval_new_symbol("quote"),
                         read_form(reader));
        break;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>First statically typed language. Led to
                restructuring of the earlier 3 implementations. More
                patterns became apparent.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Python</h2>
            <pre><code class="python" data-trim contenteditable>
...
def read_form(reader):
    token = reader.peek()
    # reader macros/transforms
    if token[0] == ';':
        reader.next()
        return None
    elif token == '\'':
        reader.next()
        return _list(_symbol('quote'), read_form(reader))
    elif token == '`':
        reader.next()
        return _list(_symbol('quasiquote'), read_form(reader))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Mal had become a fairly different Lisp from Lispy
                by this point. It modelled it on Clojure's syntax and
                immutability because that was the Lisp I knew and
                loved. But since Python was loosely part of the
                heritage I decided I had to do python too.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Clojure</h2>
            <pre><code class="clojure" data-trim contenteditable>
...
;; Override some tools.reader reader macros so that we can do our own
;; metadata and quasiquote handling
(alter-var-root #'r/macros
  (fn [f]
    (fn [ch]
      (case ch
        \` (wrap 'quasiquote)
        \~ (fn [rdr comma]
             (if-let [ch (rt/peek-char rdr)]
               (if (identical? \@ ch)
                 ((wrap 'splice-unquote) (doto rdr rt/read-char) \@)
                 ((wrap 'unquote) rdr \~))))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>And of course, since Mal is a Clojure-like Lisp,
                I had to do in implementation in Clojure.
                <li>This was really enlightening in terms of what
                parts of Mal were really Lisp nature, and which parts
                were really just incidental complexity due to
                nature or dificiencies of the target language. And
                I began to strongly structure the code and the
                incremental steps to reflect that.
                <li>However, I should point out that I later realized
                that the "incidental complexity" is actually one of
                the most useful aspects of mal, but we'll get to that.
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <h2>An Accidental Discovery</h2>
          <p class="fragment">"<font color="green">Ma</font>ke <font color="green">L</font>isp" became "<font color="green">M</font>ake-<font color="green">A</font>-<font color="green">L</font>isp"
          <aside class="notes">
            <ul>
              <li>At some point I began to realize that Mal had become
              a very useful personal learning tool. I was able to
              learn new languages more quickly and to a greater depth
              than any other process I had used.
              <li>But before we switch gears and focus on the language
              learning aspects of the make-a-lisp process, let's
              take brief look at mal the language along with a couple
              of implementations.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Mal Itself</h2>
          <p>Demo Time</p>
          <img class="fragment" src="media/mindblown.gif"></img>
          <aside class="notes">
            <font size="1em">
            <ul>
              <li>Let's use the same hello world mal program from
              before
<pre style="margin: 0px; background: #aaa;">
cd ../python
cat ../mal/hello.py</pre>
              <li>but let's run it with the python implementation:
<pre style="margin: 0px; background: #aaa;">
./mal.py ../mal/hello.py</pre>
              <li>Let's try something a bit more interesting but this
              time using the bash implementation:
<pre style="margin: 0px; background: #aaa;">
cd ../bash
./mal.sh ../mal/clojurewest2014.mal</pre>
              <li>That's a presentation for a lightning talke I did on
              mal at Clojure West.
<pre style="margin: 0px; background: #aaa;">
less ../mal/clojurewest2014.mal</pre>
              <li>That's all well and good, but let's bump it up
              a notch or three:
<pre style="margin: 0px; background: #aaa;">
cd ../js
./mal.js ../mal/mal.mal</pre>
              <li>I'll just pause for a second to let you stew on
              that.
              <li>Yes, that's the mal implementation of mal
              <li>[show gif]
              <li>More specifically, that's the JavaScript
              implementation of mal being used to run an
              implementation of mal that is written in the mal
              language itself]
<pre style="margin: 0px; background: #aaa;">
less ../mal/mal.mal</pre>
              <li>And of course we can do this:
<pre style="margin: 0px; background: #aaa;">
./mal.js ../mal/mal.mal ../mal/hello.mal</pre>
              <li>It's much slower, but it works the same
            </ul>
            </font>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal and More Mal</h2>
          </section>
          <section>
            <h2>PHP</h2>
            <pre><code class="php" data-trim contenteditable>
...
function read_form($reader) {
    $token = $reader->peek();
    switch ($token) {
    case '\'': $reader->next();
               return _list(_symbol('quote'),
                               read_form($reader));
    case '`':  $reader->next();
               return _list(_symbol('quasiquote'),
                               read_form($reader));
    case '~':  $reader->next();
               return _list(_symbol('unquote'),
                               read_form($reader));
...
            </code></pre>
          </section>

          <section>
            <h2>Java</h2>
            <pre><code class="java" data-trim contenteditable>
...
    public static MalVal read_form(Reader rdr)
            throws MalContinue, ParseError {
        String token = rdr.peek();
        if (token == null) { throw new MalContinue(); }
        MalVal form;

        switch (token.charAt(0)) {
            case '\'': rdr.next();
                       return new MalList(new MalSymbol("quote"),
                                          read_form(rdr));
            case '`': rdr.next();
                      return new MalList(new MalSymbol("quasiquote"),
                                         read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>PostScript</h2>
            <pre><code class="TODO" data-trim contenteditable>
...
% read_form: read the next form from string start at idx
/read_form { 3 dict begin
    read_spaces
    /idx exch def
    /str exch def

    idx str length ge { null str idx }{ %if EOF

    /ch str idx get def  % current character
    ch 39 eq { %if '\''
        /idx idx 1 add def
        str idx read_form
        3 -1 roll   /quote exch 2 _list   3 1 roll
...
            </code></pre>
          </section>

          <section>
            <h2>C#</h2>
            <pre><code class="csharp" data-trim contenteditable>
...
        public static MalVal read_form(Reader rdr) {
            string token = rdr.peek();
            if (token == null) { throw new MalContinue(); }
            MalVal form = null;

            switch (token) {
                case "'": rdr.next();
                    return new MalList(new MalSymbol("quote"),
                                       read_form(rdr));
                case "`": rdr.next();
                    return new MalList(new MalSymbol("quasiquote"),
                                       read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>Ruby</h2>
            <pre><code class="ruby" data-trim contenteditable>
...
def read_form(rdr)
    return case rdr.peek
        when ";" then  nil
        when "'" then  rdr.next; List.new [:quote, read_form(rdr)]
        when "`" then  rdr.next; List.new [:quasiquote, read_form(rdr)]
        when "~" then  rdr.next; List.new [:unquote, read_form(rdr)]
        when "~@" then rdr.next; List.new [:"splice-unquote", read_form(rdr)]
        when "^" then  rdr.next; meta = read_form(rdr);
                       List.new [:"with-meta", read_form(rdr), meta]
...
            </code></pre>
          </section>

          <section>
            <h2>Perl</h2>
            <pre><code class="perl" data-trim contenteditable>
...
sub read_form {
    my($rdr) = @_;
    my $token = $rdr->peek();
    given ($token) {
        when("'") { $rdr->next(); List->new([Symbol->new('quote'),
                                             read_form($rdr)]) }
        when('`') { $rdr->next(); List->new([Symbol->new('quasiquote'),
                                             read_form($rdr)]) }
        when('~') { $rdr->next(); List->new([Symbol->new('unquote'),
                                             read_form($rdr)]) }
...
            </code></pre>
          </section>

          <section>
            <h2>Go</h2>
            <pre><code class="golang" data-trim contenteditable>
...
func read_form(rdr Reader) (MalType, error) {
        token := rdr.peek()
        if token == nil {
                return nil, errors.New("read_form underflow")
        }
        switch *token {
        case `'`:
                rdr.next()
                form, e := read_form(rdr)
                if e != nil {
                        return nil, e
                }
                return List{[]MalType{Symbol{"quote"}, form}, nil}, nil
...
            </code></pre>
          </section>

          <section>
            <h2>Rust</h2>
            <pre><code class="rust" data-trim contenteditable>
...
fn read_form(rdr : &mut Reader) -> MalRet {
    let otoken = rdr.peek();
    let stoken = otoken.unwrap();
    let token = &stoken[..];
    match token {
        "'" => {
            let _ = rdr.next();
            match read_form(rdr) {
                Ok(f) => Ok(list(vec![symbol("quote"), f])),
                Err(e) => Err(e),
            }
        },
...
            </code></pre>
          </section>

          <section>
            <h2>R</h2>
            <pre><code class="r" data-trim contenteditable>
...
read_form &lt;- function(rdr) {
    token &lt;- Reader.peek(rdr)
    if (token == "'") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quote"), read_form(rdr))
    } else if (token == "`") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quasiquote"), read_form(rdr))
    } else if (token == "~") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("unquote"), read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>CoffeeScript</h2>
            <pre><code class="coffeescript" data-trim contenteditable>
...
read_form = (rdr) ->
  token = rdr.peek()
  switch token
    when '\'' then [_symbol('quote'), read_form(rdr.skip())]
    when '`'  then [_symbol('quasiquote'), read_form(rdr.skip())]
    when '~'  then [_symbol('unquote'), read_form(rdr.skip())]
    when '~@' then [_symbol('splice-unquote'), read_form(rdr.skip())]
    when '^'
      meta = read_form(rdr.skip())
      [_symbol('with-meta'), read_form(rdr), meta]
    when '@' then [_symbol('deref'), read_form(rdr.skip())]
...
            </code></pre>
          </section>

          <section>
            <h2>VB.NET</h2>
            <pre><code class="vbnet" data-trim contenteditable>
...
        Shared Function read_form(rdr As Reader) As MalVal
            Dim token As String = rdr.peek()
            If token Is Nothing Then
                throw New MalContinue()
            End If
            Dim form As MalVal = Nothing

            Select token
            Case "'"
                rdr.get_next()
                return New MalList(New MalSymbol("quote"),
                                   read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>Scala</h2>
            <pre><code class="scala" data-trim contenteditable>
...
  def read_form(rdr: Reader): Any = {
    return rdr.peek() match {
      case "'"  => { rdr.next; _list(Symbol("quote"), read_form(rdr)) }
      case "`"  => { rdr.next; _list(Symbol("quasiquote"), read_form(rdr)) }
      case "~"  => { rdr.next; _list(Symbol("unquote"), read_form(rdr)) }
      case "~@" => { rdr.next; _list(Symbol("splice-unquote"), read_form(rdr)) }
      case "^"  => { rdr.next; val meta = read_form(rdr);
                     _list(Symbol("with-meta"), read_form(rdr), meta) }
      case "@"  => { rdr.next; _list(Symbol("deref"), read_form(rdr)) }
...
            </code></pre>
          </section>

          <section>
            <h2>Haskell</h2>
            <pre><code class="haskell" data-trim contenteditable>
...
read_form :: Parser MalVal
read_form =  do
    ignored
    x &lt;- read_macro
     &lt;|> read_list
     &lt;|> read_vector
     &lt;|> read_hash_map
     &lt;|> read_atom
    return $ x

read_str :: String -> IOThrows MalVal
read_str str = case parse read_form "Mal" str of
...
            </code></pre>
          </section>

          <section>
            <h2>Racket</h2>
            <pre><code class="scheme" data-trim contenteditable>
...
(define (read_form rdr)
  (let ([token (send rdr peek)])
    (if (null? token)
      (raise (make-blank-exn "blank line" (current-continuation-marks)))
      (cond
        [(equal? "'" token) (send rdr next) (list 'quote (read_form rdr))]
        [(equal? "`" token) (send rdr next) (list 'quasiquote (read_form rdr))]
        [(equal? "~" token) (send rdr next) (list 'unquote (read_form rdr))]
        [(equal? "~@" token) (send rdr next) (list 'splice-unquote (read_form rdr))]
        [(equal? "^" token) (send rdr next)
                            (let ([meta (read_form rdr)])
                              (list 'with-meta (read_form rdr) meta))]
...
            </code></pre>
          </section>

          <section>
            <h2>Lua</h2>
            <pre><code class="lua" data-trim contenteditable>
...
function M.read_form(rdr)
    local token = rdr:peek()

    if "'" == token then
        rdr:next()
        return List:new({Symbol:new('quote'), M.read_form(rdr)})
    elseif '`' == token then
        rdr:next()
        return List:new({Symbol:new('quasiquote'), M.read_form(rdr)})
    elseif '~' == token then
        rdr:next()
        return List:new({Symbol:new('unquote'), M.read_form(rdr)})
...
            </code></pre>
          </section>

          <section>
            <h2>OCaml</h2>
            <pre><code class="ocaml" data-trim contenteditable>
...
and read_form all_tokens =
  match all_tokens with
    | [] -> raise End_of_file;
    | token :: tokens ->
      match token with
        | "'"  -> read_quote "quote" tokens
        | "`"  -> read_quote "quasiquote" tokens
        | "~"  -> read_quote "unquote" tokens
        | "~@" -> read_quote "splice-unquote" tokens
        | "@"  -> read_quote "deref" tokens
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>OCaml was implementation #23
                <li>Notable because it was the first implementation done by somebody else.
              </ul>
            </aside>
          </section>
        </section>

        <section data-background="#ffffff">
          <h3>Mal Today</h3>
          <img class="fragment" src="media/language_montage.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Which bring us to today. [Display diagram]
              <li>There are now 42 implementations.
              <li>14 of the last 20 were created by others.
              <li>The past 12 months have averaged more than
              2 implementations per month.
              <li>At this point you might be asking yourself "Why"?
              Actually displaying it this way, I'm asking that myself.
              Why go through all that work?
              <li>The answer is actually really simple: because it was
              fun! And not just fun, but addictive.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Putting the Fun in Language Learning</h2>
          <p><span class="fragment">Buzzword alert:</span> <span class="fragment"><font color="yellow">Gamification</font></span></p>
          <p><span class="fragment">Make-A-Lisp is gamification of language learning</span></p>
          <p><span class="fragment">The end goal happens to be a working Lisp interpreter</span></p>
          <aside class="notes">
            <ul>
              <li>Gamification as a term has become a bit tired. But
              the principle it is referring to is really important.
              <li>The reason that the make-a-lisp process has worked
              so well (and not just for me) is because it evolved into
              an addictive game.
              <li>Now let's dive into how we turn work into a game.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Game of Work</h2>
          <ol>
            <li class="fragment">Goals
            <li class="fragment">Scorekeeping
            <li class="fragment">Choice
            <li class="fragment">Coaching
            <li class="fragment">Feedback
            <!-- TODO: other gamification ideas-->
          </ol>
          <aside class="notes">
            <ul>
              <li>These ideas are from Charles Coonradt's book "The
              Game of Work". Originally writen in TODO YEAR. There's
              been a lot more written about gamification since then
              and many other ideas about how to turn work and other
              hard activities into a game. But certainly, those
              5 principles do encapsulate some of the most important
              ideas.
              <li>So let's talk about how the make-a-lisp process
              applies those principles. 
              <li>As I mentioned before, I accidentally stumbled on
              many of these ideas in mal, but since that point I have
              been tweaking the process to try and maximize it's
              fun and utility.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Goals</h2>
          <ul>
            <li class="fragment">Learn a New Language
            <li class="fragment">Learn About Lisp
            <li class="fragment">---
            <li class="fragment">Create a Lisp (i.e. Mal implementation)
            <li class="fragment">Get Eternal Glory <span class="fragment">(at <a href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a>)</span>
            <ul>
              <li class="fragment">Getting your implementation into
              the main repository
              <ul>
                <li class="fragment">First to implement a new target
                <li class="fragment">Something unique and interesting
                about your implemenation
              </ul>
              <li class="fragment">Getting props for a re-implementation
            </ul>
          </ul>
          <aside class="notes">
            <ul>
              <li>Goals: the desired results.
              <li>Although the first two are the real goals, it's
              important to have goals that are clear and easy to
              measure/verify.
              <li>But as long as you don't cheat and copy another
              implementation, once you've created your mal
              implementation, you will have accomplished the former
              two.
              <li>"first" is really a subset of "unique and interesting"
              <li>"unique and interesting": different way of mapping
              Mal types to the target language, more efficient
              immutable data structure implementation, a more
              idiomatic implementation in target language, etc.
              <li>if you simply re-implement an existing target,
              that's still worthy of recognition. Let me know and as
              long as it's not just a copy of an existing
              implementation, I'll link to it from the main
              repository.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Scorekeeping</h2>
          <p>Measure of progress towards goal</p>
          <ul>
            <li class="fragment" data-fragment-index="1">step0_repl
<!--              <span class="fragment" data-fragment-index="2"> - Echo program-->
            <li class="fragment" data-fragment-index="1">step1_read_print
<!--              <span class="fragment" data-fragment-index="3"> - Lisp syntax checker-->
            <li class="fragment" data-fragment-index="1">step2_eval
<!--              <span class="fragment" data-fragment-index="4"> - Simple (prefix) calculator-->
            <li class="fragment" data-fragment-index="1">step3_env
<!--              <span class="fragment" data-fragment-index="5"> - Simple (prefix) calculator with memory-->
            <li class="fragment" data-fragment-index="1">step4_if_fn_do
<!--              <span class="fragment" data-fragment-index="6"> - Simple Lisp language-->
            <li class="fragment" data-fragment-index="1">step5_tco
<!--              <span class="fragment" data-fragment-index="7"> - Tail-call optimization-->
            <li class="fragment" data-fragment-index="1">step6_file
<!--              <span class="fragment" data-fragment-index="8"> - I/O, load-file, eval-->
            <li class="fragment" data-fragment-index="1">step7_quote
<!--              <span class="fragment" data-fragment-index="9"> - Quoting/quasiquoting (code templating)-->
            <li class="fragment" data-fragment-index="1">step8_macros
<!--             <span class="fragment" data-fragment-index="10"> - User defined language syntax-->
            <li class="fragment" data-fragment-index="1">step9_try
<!--              <span class="fragment" data-fragment-index="11"> - Exception handling-->
            <li class="fragment" data-fragment-index="1">stepA_mal
<!--              <span class="fragment" data-fragment-index="12"> - Self-hosting-->
          </ul>
          <ul style="list-style-type: none; margin: 0px; padding: 0px;">
            <li class="fragment" data-fragment-index="2">Echo program
            <li class="fragment" data-fragment-index="3">Syntax checker
            <li class="fragment" data-fragment-index="4">Simple calculator (prefix)
            <li class="fragment" data-fragment-index="5">Calculator with memory
            <li class="fragment" data-fragment-index="6">Simple Lisp Language
            <li class="fragment" data-fragment-index="7">Efficient stack/memory (Tail-calls)
            <li class="fragment" data-fragment-index="8">File I/O, eval, command line
            <li class="fragment" data-fragment-index="9">Code templating (quasiquote)
            <li class="fragment" data-fragment-index="10">User defined syntax (macros)
            <li class="fragment" data-fragment-index="11">Exception handling
            <li class="fragment" data-fragment-index="12">Self-hosting
          </ul>
          <aside class="notes">
            <ul>
              <li>Simple and Objective
              <li>Self-administered
              <li>Comparison
              <ul>
                <li>personal past and present performance
                <li>to accepted standard
              </ul>
              <li>Dynamic
              <ul>
                <li>know at all times where you stand
              </ul>
              <li>In the make-a-lisp process, there 11 scores (or
              steps) towards the end goal
            </ul>
          </aside>
        </section>

        <section>
          <h2>Choice</h2>
          <p>Freedom to choose how to succeed</p>
          <ul>
            <li class="fragment">Target language and tools
            <li class="fragment">Implementation decisions
            <li class="fragment">Optional or deferrable steps/tasks
            <ul>
              <li>step 5 / TCO
              <li>readline editing/history
              <li>metadata across all compound data-types
              <li>keywords, vectors and hash-maps
              <li>reader macros, comments
            </ul>

          </ul>
          <aside class="notes">
            <ul>
              <li>Most steps have significant number of
            deferrable features. Especially some data-types such as
            strings, keywords, vectors, hash-maps.
              <li>Some deferrable/optional things are required for
              self-hosting such as vectors, hash-maps and function metadata.
              Other things are purely optional such as keywords and
              metadata on other data-types. 
            </ul>
          </aside>
        </section>

        <section>
          <h2>Coaching</h2>
          <ul>
            <li class="fragment">Step-by-step guide at
            <a
                href="https://github.com/kanaka/mal/blob/master/process/guide.md">blob/master/process/guide.md</a>
            <ul>
                <li>Logical feature diagram for each step:<br> e.g. <a
                    href="https://github.com/kanaka/mal/blob/master/process/guide.md#step0">step0</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step1">step1</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step2">step2</a>
            </ul>
            <li class="fragment">Psuedo-code for each step
            <li class="fragment">FAQ at <a href="https://github.com/kanaka/mal/blob/master/docs/FAQ.md">blob/master/docs/FAQ.md</a>
            <li class="fragment">#mal channel on freenode
          </ul>
          <aside class="notes">
            <ul>
              <li>TODO "Field of Play" (see FAQ)
            </ul>
          </aside>
        </section>

        <section>
          <h2>Feedback</h2>
          <ul>
            <li class="fragment">Measuring change over time
            <li class="fragment">Frequent feedback
            <li class="fragment">In make-a-lisp feedback works like
            this:
            <pre><code class="bash" data-trim contenteditable>
make test^MY_IMPL
</code></pre>
          </ul>
          <aside class="notes">
            <ul>
              <li>Demo/show foo/python step0
              <li>Looking up keyboard input for python on
              stackoverflow
              <li>Put in wrong output
              <li>Show test file
              <li>Run test
              <li>Explain test counts and the output format
              <li>Fix output
              <li>Show test again
              <li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Your Turn!</h2>
          <ul>
            <li>Learn a new language using mal
            <li>Create an new implementation
            <li>Improve the game
            <li>Improve an existing implementation
            <li>Do some language research with mal implementations
          </ul>
          <aside class="notes">
            <ul>
              <li>Learn a new language using mal
              <li>Create an new implementation:
              <ul>
                <li>Something old: Fortran, COBOL, Ada, Pascal
                <li>Something new: Idris, Io, Dart, Elm
                <li>Something borrowed: Objective-C, Tcl, Tex
                <li>Something blue: MUMPS
              </ul>
              <li>Improve the game
              <ul>
                <li>Graphical feedback
                <li>Social aspect (programming competition, leaderboard,
                etc)
              </ul>
              <li>Improve an existing implementation:
              <ul>
                <li>More idiomatic
                <li>More memory efficient, better performing
                <li>Better target language interop
              </ul>
              <li>Do some research using existing mal implementations
            </ul>
          </aside>
        </section>

        <section>
          <h2>Questions</h2>
        </section>

        <section data-background="#ffffff">
          <img src="media/language_graph.png"
               width="70%" style="box-shadow: none;"></img>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
