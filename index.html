<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Achievement Unlocked - A Better Path to Language Learning</title>

    <meta name="description" content="Turning the process of learning new programming languages into an addictive game: make-a-lisp">
    <meta name="author" content="Joel Martin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Achievement Unlocked</h1>
          <h3>A Better Path to Language Learning</h3>
          <p>Midwest.io 2015</p>
          <p>Joel Martin</p>
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>Have sized window for mal demo open
              <li>Prune foo from Makefile and foo/
              <li>Build impls: bash, python, js, mal
              <li>Setup screen sharing
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">guide</a>
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step0">step0 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step1">step1 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step2">step2 image</a> in presentation window for quick tabbing.
            </ul>
          </aside>
        </section>

        <section>
          <h2>About Me</h2>
          <p>Joel Martin (kanaka)</a></p>
          <p><a href="https://github.com/kanaka">github.com/kanaka</a></p>
          <p><a href="http://twitter.com/buskanaka">@buskanaka</a></p>
          <p>Principal Software Engineer at ViaSat, Inc</p>
          <p class="fragment">Clojure</p>
          <p class="fragment">Satellites!</p>
          <aside class="notes">
            <ul>
                <li>My name is Joel Martin
                <li>Principal Software Engineer at ViaSat, Inc
                <li>At ViaSat I get to build systems using <span
                class="next">&gt;&gt;</span> Clojure, work with some
                amazing people, and <span class="next">&gt;&gt;</span>
                work at a company that does broadband Internet from
                space.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Welcome to Polyglossia</h2>
          <ul class="fragment" data-fragment-index="1">
            <li>Groovy (2003)
            <li>Scala (2004)
            <li>Go (2009)
            <li>Swift (2014)
          </ul>
          <ul class="fragment" data-fragment-index="2">
            <li>Clojure (2007)
            <li>Rust (2010)
            <li>Julia (2012)
            <li>Dart (2013)
          </ul>
          <ul class="fragment" data-fragment-index="3">
            <li>Factor (2003)
            <li>Nim (2008)
            <li>Kotlin (2011)
            <li>Crystal (2012)
          </ul>
          <div style="margin-left: 5em;">
          <p class="fragment" data-fragment-index="4" style="text-align: left;">
            The Best Language<font color="#ffea9a" class="fragment" data-fragment-index="6">s</font>
            for the &nbsp;
            <span style="position: relative; color: #ffea9a;">
              <span class="fragment fade-in" data-fragment-index="4" style="position: absolute;">
                <span class="fragment fade-out" data-fragment-index="5">
                Organization
                </span>
              </span>
              <span class="fragment fade-in" data-fragment-index="5" style="position: absolute;">
                <span class="fragment fade-out" data-fragment-index="6">
                Task/Project
                </span>
              </span>
              <span class="fragment fade-in" data-fragment-index="6" style="position: absolute;">
                System
              </span>
            </span>
          </p>
          </div>
          <p class="fragment" data-fragment-index="7">
            It's a Polyglot World
          </p>
          <p class="fragment" data-fragment-index="8">
            Language learning is part of the job.
          </p>
          <aside class="notes">
            <ul>
              <li>Show of hands: how many of you have written non-trivial
              code in more than one programming language over the past:
              <ul>
                <li>- year?, - month?, - week?, - today?
              </ul>
              <li>The rate of language creation isn't slowing
              down.
              <li><span class="next">&gt;&gt;</span> I suspect almost
              everybody here has heard of these
              <li><span class="next">&gt;&gt;</span> There is a good
              chance you've heard of these.
              <li><span class="next">&gt;&gt;</span> But you not have
              heard of these.  But in fact these are all really
              interesting languages and you should look them up (after
              this talk of course).
              <li>As an industry we've moved from a <span
              class="next">&gt;&gt;</span> standard language per
              company/organization, <span class="next">&gt;&gt;</span>
              to best language for the task, <span
              class="next">&gt;&gt;</span> to best langauges for the
              system.
              <li><span class="next">&gt;&gt;</span> It's a PolyGlot
              World. <span class="next">&gt;&gt;</span> Regularly
              learning new languages is just part of what it means to
              be a software developer.
            </ul>
          </aside>
        </section>

<!--
        <section>
          <h2>Growing Profusion</h2>
          <p class="fragment">
            ... and Growing Confusion
          </p>
          <ul class="fragment">
            <li>Groovy (2003)
            <li>Scala (2003)
            <li>Go (2009)
            <li>Swift (2014)
          </ul>
          <ul class="fragment">
            <li>Clojure (2003)
            <li>Rust (2003)
            <li>Dart (2009)
            <li>Factor (2014)
          </ul>
          <ul class="fragment">
            <li>Factor (2003)
            <li>Nim (2008)
            <li>Kotlin (2011)
            <li>Crystal (2012)
          </ul>
          <aside class="notes">
            <p>The rate of language creation isn't slowing down.</p>
            <p>Hidden 1 [First Set]: I suspect almost everybody here
            has heard of these</p>
            <p>Hidden 2 [Second Set]: There is a good chance you've
            heard of these.</p>
            <p>Hidden 3 [Third Set]: But you not have heard of these.
            But in fact these are all really interesting languages and
            you should look them up (after this talk of course).</p>
          </aside>
        </section>

        <section>
          <h2>The Name of the Game</h2>
          <ul>
              <li>The Best Language for the Company/Organization
              <li class="fragment">The Best Language for the Task/Project
              <li class="fragment">The Best Language<font color="red">s</font> for the System
              <ul>
                  <li class="fragment">APIs
                  <li class="fragment">Interop
                  <ul class="fragment">
                      <li>FFI
                      <li>Language Virtual Machines (JVM, CLR)
                  </ul>
                  <li class="fragment">Common Compilation Targets (Transpilers)
              </ul>
              <li class="fragment">Single language jobs/projects are
              a dying breed.
              <li class="fragment">You must become Polygot to succeed.
          </ul>
          <aside class="notes">
            <p>Hidden [Interop]: Groovy, Scala, Clojure, Kotlin all run
            on the JVM and can call into code written in the other
            language</p>
            <p>Hidden [Transpile]: Everything compiles to JavaScript
            these days</p>
            <p>For a new language to be successful, it must find
            a point of leverage</p>
          </aside>
        </section>
-->

        <section>
          <h2>Learning is work!</h2>
          <h2 class="fragment">Work is inherently difficult</h2>
          <p class="fragment">The typical process:</p>
          <ul>
            <li class="fragment">Hello world
            <li class="fragment">Function definition and calling
            <li class="fragment">Basic data types
            <li class="fragment">Basic flow control constructs
            <li class="fragment">Etc, etc, ad naseum
          </ul>
          <aside class="notes">
            <ul>
              <li>Most popular languages have a wealth of learning
              resources. Many even have step-by-step incremental
              tutorials to help you learn the language.
              <li><span class="next">&gt;&gt;</span> But regardless,
              the process usually involves <span
              class="next">&gt;&gt;</span> <span
              class="next">&gt;&gt;</span> <span
              class="next">&gt;&gt;</span> <span
              class="next">&gt;&gt;</span>
              <li>Some of the best learning resources are like reading
              quirky books (e.g.  "Learn you a Haskell for Great Good"
              and "Why's Poignant Guide to Ruby"), but they are still
              just basically humorous narrative forms of the same
              process.
              <li>And so language learning requires you to tediously
              push your brain up hill a couple of inches at a time
              until you reach a high enough foothill where you can
              implement your first real thing in the language.
              <li>It's hard work. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section>
          <h2>... or is it?</h2>
          <blockquote class="fragment" cite="Game of Work - Coonradt, Ch. 1">
            &ldquo;Why will people pay for the privilege of working
            harder than they will work when they are paid?<br>
            -- The Game of Work: Charles Coonradt&rdquo;
          </blockquote>
          <p class="fragment">"Work" is not a thing, it's a state of mind.</p>
          <aside class="notes">
            <span class="next">&gt;&gt;</span>
            <p>A quote from Charles Coonradt</p>
            <p>Meat packers might act like they have the job from
            hell, but then those same people might gladly pay to go
            hunting in the dead of winter.</p>
            <!--
            <p>The same people who have trouble pulling themselves out
            of bed a 7AM to go to work in their 72 degree office, will
            happily wake up at 4AM to go skiing in frigid weather.</p>
            -->
            <p>The fact is <span class="next">&gt;&gt;</span> "Work"
            is not a thing.
          </aside>
        </section>

        <section>
          <h2>The Inspiration</h2>
          <ul>
              <li class="fragment" data-fragment-index="1">Gherkin<br>
              <li class="fragment" data-fragment-index="3">lispy</li>
              <span class="fragment fade-in" data-fragment-index="2">
                <span class="fragment fade-out" data-fragment-index="3">
                  <img src="media/mindblown.gif"></img>
                </span>
              </span>
          </ul>
          <aside class="notes">
            <ul>
                <li>I'm going to tell you a personal story about
                language learning.
                <li>
                  <ul>
                    <li> <span class="next">&gt;&gt;</span> Way back in 2013, Alan Dipert presented this at Clojure/conj
                    <li>A Lisp implemented in bash <span class="next">&gt;&gt;</span> [mindblown]
                    <li>This was basically my reaction.
                    <li>Raised the question for me: what other
                    non-traditional language could a Lisp be
                    implemented in?
                    <li>Had particular language in mind. As far as
                    I knew, no one had ever written a Lisp using it.
                    You'll see why in a moment.
                  </ul>
                <li><span class="next">&gt;&gt;</span> Lispy: a small and simple Python implementation of
                a Lisp interpreter by Peter Norvig. I used that as
                a model.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal Beginnings</h2>
            <aside class="notes">
              A bit on how mal began
              <span class="next">vv</span>
            </aside>
          </section>

          <section>
            <h2>JS</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
function read_form(reader) {
    var token = reader.peek();
    switch (token) {
    // reader macros/transforms
    case ';': return null; // Ignore comments
    case '\'': reader.next();
               return [types._symbol('quote'), read_form(reader)];
    case '`': reader.next();
              return [types._symbol('quasiquote'), read_form(reader)];
    case '~': reader.next();
              return [types._symbol('unquote'), read_form(reader)];
...
            </code></pre>
            <aside class="notes">
              First did an implementation in JS to make sure
              I understood the process well. I had not made a Lisp
              from scratch before.
            </aside>
          </section>
          <section>
            <h2 class="fragment" data-fragment-index="1">GNU Make</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
define READ_FORM
$(and $(READER_DEBUG),$(info READ_FORM: $($(1))))
$(call READ_SPACES,$(1))
$(foreach ch,$(word 1,$($(1))),\
  $(if $(filter $(SEMI),$(ch)),\
    $(call DROP_UNTIL,$(1),$(_NL)),\
  $(if $(filter $(SQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(QQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quasiquote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(UNQUOTE),$(ch)),\
...
            </code></pre>
            <p class="fragment" class="fragment" data-fragment-index="2">"<font color="green">Ma</font>ke <font color="green">L</font>isp"
            <aside class="notes">
              <ul>
                <li>Here is a sample of the code from the target
                language that I was inspired to write a Lisp in.
                Anybody willing to guess what language this example
                code is written in?
                <li><span class="next">&gt;&gt;</span> GNU Make. And
                yes, it's really does work and it's a full
                implementation.
                <li><span class="next">SWITCH</span>
                <li>Demo
                <pre style="background: #aaa;">
cd make
make -f ./mal.mk
user&gt; ( (fn* [a b] (* a b)) 7 8)
less mal.mk</pre>
                <li><span class="next">SWITCH</span> <span
                    class="next">&gt;&gt;</span> The name "Mal"
                original "MAke Lisp" because that was all I was really
                originally intenteding to do. But then I had the
                thought...
                <li>Should be at <span class="next">10</span> min mark
              </ul>
          </section>
          <section>
            <h2>Bash</h2>
            <pre><code class="bash" data-trim contenteditable>
...
READ_FORM () {
  local token=${__reader_tokens[${__reader_idx}]}
  case "${token}" in
    \')   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
    \`)   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quasiquote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>My JS and Make Lisp interpreters had a fairly
                different structure compared to Gherkin. So I decided
                to try my hand at Bash.
                <li>Began to see patterns. Started thinking in terms
                of small digestable chunks, largely due to the fact my
                life, job and school meant I only had short segments
                of time to work on it.
                <li>Often it was at night while working on graduate
                classes when I would take a 5-10 minute break and work
                on whatever current mal implementation I happened to
                have in the pipeline. And I'm not that brilliant so
                I was forced to make a process that was very gradual
                and incremental.
              </ul>
            </aside>
          </section>
          <section>
            <h2>C</h2>
            <pre><code class="c" data-trim contenteditable>
...
MalVal *read_form(Reader *reader) {
    char *token;
    MalVal *form = NULL, *tmp;
    token = reader_peek(reader);
    if (!token) { return NULL; }
    switch (token[0]) {
    case ';':
        abort("comments not yet implemented");
        break;
    case '\'':
        reader_next(reader);
        form = _listX(2, malval_new_symbol("quote"),
                         read_form(reader));
        break;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>First statically typed language. Led to
                restructuring of the earlier 3 implementations. More
                patterns became apparent.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Python</h2>
            <pre><code class="python" data-trim contenteditable>
...
def read_form(reader):
    token = reader.peek()
    # reader macros/transforms
    if token[0] == ';':
        reader.next()
        return None
    elif token == '\'':
        reader.next()
        return _list(_symbol('quote'), read_form(reader))
    elif token == '`':
        reader.next()
        return _list(_symbol('quasiquote'), read_form(reader))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Mal had become a fairly different Lisp from Lispy
                by this point. It modelled it on Clojure's syntax and
                immutability because that was the Lisp I knew and
                loved. But since Python was loosely part of the
                heritage I decided I had to do python too.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Clojure</h2>
            <pre><code class="clojure" data-trim contenteditable>
...
;; Override some tools.reader reader macros so that we can do our own
;; metadata and quasiquote handling
(alter-var-root #'r/macros
  (fn [f]
    (fn [ch]
      (case ch
        \` (wrap 'quasiquote)
        \~ (fn [rdr comma]
             (if-let [ch (rt/peek-char rdr)]
               (if (identical? \@ ch)
                 ((wrap 'splice-unquote) (doto rdr rt/read-char) \@)
                 ((wrap 'unquote) rdr \~))))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>And of course, since Mal is a Clojure-like Lisp,
                I had to do in implementation in Clojure.
                <li>This was really enlightening in terms of what
                parts of Mal were really Lisp nature, and which parts
                were really just incidental complexity due to
                nature or dificiencies of the target language. And
                I began to strongly structure the code and the
                incremental steps to reflect that.
                <li>However, I should point out that I later realized
                that the "incidental complexity" is actually one of
                the most useful aspects of mal, but we'll get to that.
              </ul>
            </aside>
          </section>

          <section>
            <h2>PHP</h2>
            <pre><code class="php" data-trim contenteditable>
...
function read_form($reader) {
    $token = $reader->peek();
    switch ($token) {
    case '\'': $reader->next();
               return _list(_symbol('quote'),
                               read_form($reader));
    case '`':  $reader->next();
               return _list(_symbol('quasiquote'),
                               read_form($reader));
    case '~':  $reader->next();
               return _list(_symbol('unquote'),
                               read_form($reader));
...
            </code></pre>
          </section>

          <section>
            <h2>Java</h2>
            <pre><code class="java" data-trim contenteditable>
...
    public static MalVal read_form(Reader rdr)
            throws MalContinue, ParseError {
        String token = rdr.peek();
        if (token == null) { throw new MalContinue(); }
        MalVal form;

        switch (token.charAt(0)) {
            case '\'': rdr.next();
                       return new MalList(new MalSymbol("quote"),
                                          read_form(rdr));
            case '`': rdr.next();
                      return new MalList(new MalSymbol("quasiquote"),
                                         read_form(rdr));
...
            </code></pre>
          </section>
        </section>

        <section>
          <h2>An Accidental Discovery</h2>
          <p class="fragment">"<font color="green">Ma</font>ke <font color="green">L</font>isp" became "<font color="green">M</font>ake-<font color="green">A</font>-<font color="green">L</font>isp"
          <aside class="notes">
            <ul>
              <li>At some point I began to realize that Mal had become
              a very useful personal learning tool. I was able to
              learn new languages more quickly and to a greater depth
              than any other process I had used before.
              <li><span class="next">&gt;&gt;</span> And so Make Lisp
              became Make-A-Lisp
              <li>But before we switch gears and focus on the language
              learning aspects of the make-a-lisp process, let's
              take brief look at mal the language along with a couple
              of implementations.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Mal Itself</h2>
          <p>Demo Time</p>
          <img class="fragment" src="media/surprised-baby.gif"></img>
          <aside class="notes">
            <font size="1em">
            <ul>
              <li>Should be at <span class="next">15</span> min mark
              <li><span class="next">SWITCH</span>
              <li>Let's start with a hello world mal program:
<pre style="margin: 0px; background: #aaa;">
cd ../python
cat ../mal/hello.py</pre>
              <li>but let's run it with the python implementation:
<pre style="margin: 0px; background: #aaa;">
./mal.py ../mal/hello.py</pre>
              <li>Let's try something a bit more interesting but this
              time using the bash implementation:
<pre style="margin: 0px; background: #aaa;">
cd ../bash
./mal.sh ../mal/clojurewest2014.mal</pre>
              <li>That's a presentation for a lightning talke I did on
              mal at Clojure West.
<pre style="margin: 0px; background: #aaa;">
less ../mal/clojurewest2014.mal</pre>
              <li>That's all well and good, but let's bump it up
              a notch or three:
<pre style="margin: 0px; background: #aaa;">
cd ../js
./mal.js ../mal/mal.mal</pre>
              <li>I'll just pause for a second to let you stew on
              that.
              <li>Yes, that's the mal implementation of mal

              <li><span class="next">SWITCH</span>[show gif]
              <li>This was basically my reaction at the moment when
              mal became self-hosting.
              <li><span class="next">SWITCH</span>
<pre style="margin: 0px; background: #aaa;">
less ../mal/mal.mal
</pre>
              <li>More specifically, that's the JavaScript
              implementation of mal being used to run an
              implementation of mal that is written in the mal
              language itself
              <li>Self-hosting is the term for an interpreter or
              compiler that is written in it's own language.
<!--
<pre style="margin: 0px; background: #aaa;">
less ../mal/mal.mal</pre>
              <li>And of course we can do this:
<pre style="margin: 0px; background: #aaa;">
./mal.js ../mal/mal.mal ../mal/hello.mal</pre>
              <li>It's much slower, but it works the same
-->
            </ul>
            </font>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal and More Mal</h2>
          </section>
          <section>
            <h2>PostScript</h2>
            <pre><code class="prolog" data-trim contenteditable>
...
% read_form: read the next form from string start at idx
/read_form { 3 dict begin
    read_spaces
    /idx exch def
    /str exch def

    idx str length ge { null str idx }{ %if EOF

    /ch str idx get def  % current character
    ch 39 eq { %if '\''
        /idx idx 1 add def
        str idx read_form
        3 -1 roll   /quote exch 2 _list   3 1 roll
...
            </code></pre>
          <aside class="notes">
            <p>Yes, Postscript the typesetting language.</p>
            <p>After my lightning talk at Clojure West somebody
            suggested Postscript and so I took up the challenge.</p>
            <p>I had never written a line of code in
            a stack-based/concatenative language like Postscript</p>
            <p>More challenging than most, not as difficult as GNU
            Make</p>
          </aside>
          </section>

          <section>
            <h2>C#</h2>
            <pre><code class="csharp" data-trim contenteditable>
...
        public static MalVal read_form(Reader rdr) {
            string token = rdr.peek();
            if (token == null) { throw new MalContinue(); }
            MalVal form = null;

            switch (token) {
                case "'": rdr.next();
                    return new MalList(new MalSymbol("quote"),
                                       read_form(rdr));
                case "`": rdr.next();
                    return new MalList(new MalSymbol("quasiquote"),
                                       read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>Ruby</h2>
            <pre><code class="ruby" data-trim contenteditable>
...
def read_form(rdr)
    return case rdr.peek
        when ";" then  nil
        when "'" then  rdr.next; List.new [:quote, read_form(rdr)]
        when "`" then  rdr.next; List.new [:quasiquote, read_form(rdr)]
        when "~" then  rdr.next; List.new [:unquote, read_form(rdr)]
        when "~@" then rdr.next; List.new [:"splice-unquote", read_form(rdr)]
        when "^" then  rdr.next; meta = read_form(rdr);
                       List.new [:"with-meta", read_form(rdr), meta]
...
            </code></pre>
          </section>

          <section>
            <h2>Perl</h2>
            <pre><code class="perl" data-trim contenteditable>
...
sub read_form {
    my($rdr) = @_;
    my $token = $rdr->peek();
    given ($token) {
        when("'") { $rdr->next(); List->new([Symbol->new('quote'),
                                             read_form($rdr)]) }
        when('`') { $rdr->next(); List->new([Symbol->new('quasiquote'),
                                             read_form($rdr)]) }
        when('~') { $rdr->next(); List->new([Symbol->new('unquote'),
                                             read_form($rdr)]) }
...
            </code></pre>
          </section>

          <section>
            <h2>Go</h2>
            <pre><code class="golang" data-trim contenteditable>
...
func read_form(rdr Reader) (MalType, error) {
        token := rdr.peek()
        if token == nil {
                return nil, errors.New("read_form underflow")
        }
        switch *token {
        case `'`:
                rdr.next()
                form, e := read_form(rdr)
                if e != nil {
                        return nil, e
                }
                return List{[]MalType{Symbol{"quote"}, form}, nil}, nil
...
            </code></pre>
          </section>

          <section>
            <h2>Rust</h2>
            <pre><code class="rust" data-trim contenteditable>
...
fn read_form(rdr : &mut Reader) -> MalRet {
    let otoken = rdr.peek();
    let stoken = otoken.unwrap();
    let token = &stoken[..];
    match token {
        "'" => {
            let _ = rdr.next();
            match read_form(rdr) {
                Ok(f) => Ok(list(vec![symbol("quote"), f])),
                Err(e) => Err(e),
            }
        },
...
            </code></pre>
            <aside class="notes">
              <p>More challenging then average, but it's a very
              interesting language</p>
            </aside>
          </section>

          <section>
            <h2>R</h2>
            <pre><code class="r" data-trim contenteditable>
...
read_form &lt;- function(rdr) {
    token &lt;- Reader.peek(rdr)
    if (token == "'") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quote"), read_form(rdr))
    } else if (token == "`") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quasiquote"), read_form(rdr))
    } else if (token == "~") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("unquote"), read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>CoffeeScript</h2>
            <pre><code class="coffeescript" data-trim contenteditable>
...
read_form = (rdr) ->
  token = rdr.peek()
  switch token
    when '\'' then [_symbol('quote'), read_form(rdr.skip())]
    when '`'  then [_symbol('quasiquote'), read_form(rdr.skip())]
    when '~'  then [_symbol('unquote'), read_form(rdr.skip())]
    when '~@' then [_symbol('splice-unquote'), read_form(rdr.skip())]
    when '^'
      meta = read_form(rdr.skip())
      [_symbol('with-meta'), read_form(rdr), meta]
    when '@' then [_symbol('deref'), read_form(rdr.skip())]
...
            </code></pre>
          </section>

          <section>
            <h2>VB.NET</h2>
            <pre><code class="vbnet" data-trim contenteditable>
...
        Shared Function read_form(rdr As Reader) As MalVal
            Dim token As String = rdr.peek()
            If token Is Nothing Then
                throw New MalContinue()
            End If
            Dim form As MalVal = Nothing

            Select token
            Case "'"
                rdr.get_next()
                return New MalList(New MalSymbol("quote"),
                                   read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>Scala</h2>
            <pre><code class="scala" data-trim contenteditable>
...
  def read_form(rdr: Reader): Any = {
    return rdr.peek() match {
      case "'"  => { rdr.next; _list(Symbol("quote"), read_form(rdr)) }
      case "`"  => { rdr.next; _list(Symbol("quasiquote"), read_form(rdr)) }
      case "~"  => { rdr.next; _list(Symbol("unquote"), read_form(rdr)) }
      case "~@" => { rdr.next; _list(Symbol("splice-unquote"), read_form(rdr)) }
      case "^"  => { rdr.next; val meta = read_form(rdr);
                     _list(Symbol("with-meta"), read_form(rdr), meta) }
      case "@"  => { rdr.next; _list(Symbol("deref"), read_form(rdr)) }
...
            </code></pre>
          </section>

          <section>
            <h2>Haskell</h2>
            <pre><code class="haskell" data-trim contenteditable>
...
read_form :: Parser MalVal
read_form =  do
    ignored
    x &lt;- read_macro
     &lt;|> read_list
     &lt;|> read_vector
     &lt;|> read_hash_map
     &lt;|> read_atom
    return $ x

read_str :: String -> IOThrows MalVal
read_str str = case parse read_form "Mal" str of
...
            </code></pre>
          </section>

          <section>
            <h2>Racket</h2>
            <pre><code class="scheme" data-trim contenteditable>
...
(define (read_form rdr)
  (let ([token (send rdr peek)])
    (if (null? token)
      (raise (make-blank-exn "blank line" (current-continuation-marks)))
      (cond
        [(equal? "'" token) (send rdr next) (list 'quote (read_form rdr))]
        [(equal? "`" token) (send rdr next) (list 'quasiquote (read_form rdr))]
        [(equal? "~" token) (send rdr next) (list 'unquote (read_form rdr))]
        [(equal? "~@" token) (send rdr next) (list 'splice-unquote (read_form rdr))]
        [(equal? "^" token) (send rdr next)
                            (let ([meta (read_form rdr)])
                              (list 'with-meta (read_form rdr) meta))]
...
            </code></pre>
          </section>

          <section>
            <h2>Lua</h2>
            <pre><code class="lua" data-trim contenteditable>
...
function M.read_form(rdr)
    local token = rdr:peek()

    if "'" == token then
        rdr:next()
        return List:new({Symbol:new('quote'), M.read_form(rdr)})
    elseif '`' == token then
        rdr:next()
        return List:new({Symbol:new('quasiquote'), M.read_form(rdr)})
    elseif '~' == token then
        rdr:next()
        return List:new({Symbol:new('unquote'), M.read_form(rdr)})
...
            </code></pre>
          </section>

          <section>
            <h2><font color="green">OCaml</font></h2>
            <pre><code class="ocaml" data-trim contenteditable>
...
and read_form all_tokens =
  match all_tokens with
    | [] -> raise End_of_file;
    | token :: tokens ->
      match token with
        | "'"  -> read_quote "quote" tokens
        | "`"  -> read_quote "quasiquote" tokens
        | "~"  -> read_quote "unquote" tokens
        | "~@" -> read_quote "splice-unquote" tokens
        | "@"  -> read_quote "deref" tokens
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>OCaml was implementation #23
                <li>But there was a critical difference about the
                OCaml implementation: it was created by someone else.
                chouser (a friend and colleague who also wrote the
                book "The Joy of Clojure")
                <li>Marked a new era for mal (Jan 2015). The beginning
                of a step-by-step guide. Other people have created
                more implementations that I have since then.
                <li>Mal and make-a-lisp was no longer just my pet
                project.
                <li>Should be at <span class="next">20</span> min mark
              </ul>
            </aside>
          </section>
        </section>

        <section data-background="#ffffff">
          <h3>Mal Today</h3>
          <img class="fragment" src="media/language_montage.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Which bring us to today. <span class="next">&gt;&gt;</span>
              <li>There are now 42 implementations.
              <li>14 of the last 20 were created by others. And of the
              six I created many were either variations of exisiting
              implementations (like ES6 and rpython) or to learn
              a language for one of my PhD classes (like MATLAB) [or
              experiment with a language idea for work (miniMAL)].
              <li>The past 12 months have averaged more than
              2 implementations per month.
              <li>At this point you might be asking yourself "Why"?
              Why did a bunch of people go through the work to do
              this?
              <li>The answer is actually really simple: because it was
              fun! And not just fun, but addictive fun.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Putting the Fun in Language Learning</h2>
          <p><span class="fragment">Buzzword alert:</span> <span class="fragment"><font color="yellow">Gamification</font></span></p>
          <p><span class="fragment">Make-A-Lisp is gamification of language learning</span></p>
          <aside class="notes">
            <ul>
              <li><span class="next">&gt;&gt;</span> Buzzword alert:
                <span class="next">&gt;&gt;</span>
              <li>Gamification as a term has become a bit tired. But
              the principle it is referring to is really important.
              <li>The reason that the make-a-lisp process has worked
              so well (and not just for me) is because it evolved into
              an addictive game. <span class="next">&gt;&gt;</span>
              <li>Now let's dive into how we turn work into a game.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Game of Work</h2>
          <ol>
            <li class="fragment">Goals
            <li class="fragment">Scorekeeping
            <li class="fragment">Choice
            <li class="fragment">Coaching
            <li class="fragment">Feedback
            <!-- TODO: other gamification ideas-->
          </ol>
          <aside class="notes">
            <ul>
              <li>These ideas are from Charles Coonradt's book "The
              Game of Work". Originally writen in 1984.
              <li>Considered grandfather of gamification -- although
              term was not coined until later.
              <li>There's been a lot more written about gamification
              since then and many other ideas about how to turn work
              and other hard activities into a game. But certainly,
              Coonradt's 5 principles do encapsulate some of the most
              important ideas.
              <li>So let's talk about what these principle are and how
              the make-a-lisp process applies those principles.
              <ol>
                <li><span class="next">&gt;&gt;</span>
                Clearly defined and measurable Goals
                <li><span class="next">&gt;&gt;</span>
                Objective and standardized Scorekeeping
                <li><span class="next">&gt;&gt;</span>
                A high degree of Choice
                <li><span class="next">&gt;&gt;</span>
                Consistent Coaching and a well-defined Field of Play
                <li><span class="next">&gt;&gt;</span>
                Frequent Feedback
              </ol>
              <li>As I mentioned before, I accidentally stumbled on
              many of these ideas in mal, but since that point I have
              been tweaking the process to try and maximize it's
              fun and utility.
              <li>Also, this process isn't complete. I think there is
              much more that could be done to make make-a-lisp more
              fun and effictive.
              <li>So let's look at how those principles apply to the
              make-a-lisp process.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Goals</h2>
          <ul>
            <li class="fragment" data-fragment-index="1">Learn a New Language
            <li class="fragment" data-fragment-index="2">Learn About Lisp
            <li class="fragment" data-fragment-index="3">---
            <li class="fragment" data-fragment-index="3">Create a Lisp (i.e. Mal implementation)
            <li class="fragment" data-fragment-index="4">Get Eternal
            Glory <span class="fragment" data-fragment-index="5">(at
            <a href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a>)</span>
            <ul>
              <li class="fragment" data-fragment-index="6">Getting your implementation into
              the main repository
              <ul>
                <li>First to implement a new target
                <li>Something unique and interesting about your
                implemenation
              </ul>
              <li class="fragment" data-fragment-index="7">Getting credit for a re-implementation
            </ul>
          </ul>
          <aside class="notes">
            <ul>
              <li>Goals: the desired results.
              <li>Although the first two are the real goals, they
              don't satisfy the requirement that goals are objective
              and measurable
              <li>But as long as you don't cheat and copy another
              implementation, once you've created your mal
              implementation, you will have accomplished the former
              two.
              <li>"first" is really a subset of "unique and interesting"
              <li>"unique and interesting": different way of mapping
              Mal types to the target language, more efficient
              immutable data structure implementation, a more
              idiomatic implementation in target language, etc.
              <li>if you simply re-implement an existing target,
              that's still worthy of recognition. Let me know and as
              long as it's not just a copy of an existing
              implementation, I'll link to it from the main
              repository.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Scorekeeping</h2>
          <p>Measure of progress towards goal</p>
          <ul>
            <li class="fragment" data-fragment-index="1">step0_repl
            <li class="fragment" data-fragment-index="1">step1_read_print
            <li class="fragment" data-fragment-index="1">step2_eval
            <li class="fragment" data-fragment-index="1">step3_env
            <li class="fragment" data-fragment-index="1">step4_if_fn_do
            <li class="fragment" data-fragment-index="1">step5_tco
            <li class="fragment" data-fragment-index="1">step6_file
            <li class="fragment" data-fragment-index="1">step7_quote
            <li class="fragment" data-fragment-index="1">step8_macros
            <li class="fragment" data-fragment-index="1">step9_try
            <li class="fragment" data-fragment-index="1">stepA_mal
          </ul>
          <ul style="color: #ffff44; list-style-type: none; margin: 0px; padding: 0px;">
            <li class="fragment" data-fragment-index="2">Echo program
            <li class="fragment" data-fragment-index="3">Syntax checker
            <li class="fragment" data-fragment-index="4">Simple calculator (prefix)
            <li class="fragment" data-fragment-index="5">Calculator with memory
            <li class="fragment" data-fragment-index="6">Simple Lisp Language
            <li class="fragment" data-fragment-index="7">Efficient stack/memory (Tail-calls)
            <li class="fragment" data-fragment-index="8">File I/O, eval, command line
            <li class="fragment" data-fragment-index="9">Code templating (quasiquote)
            <li class="fragment" data-fragment-index="10">User defined syntax (macros)
            <li class="fragment" data-fragment-index="11">Exception handling
            <li class="fragment" data-fragment-index="12">Self-hosting
          </ul>
          <aside class="notes">
              <li>In the make-a-lisp process, you score 11 points to
              win the game i.e. achieve the goal.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Choice</h2>
          <p>Freedom to choose how to succeed</p>
          <ul>
            <li class="fragment">Target language and tools
            <li class="fragment">Implementation decisions
            <li class="fragment">Optional steps/tasks
            <ul>
              <li>step 5 / TCO
              <li>readline editing/history
              <li>metadata across all compound data-types
              <li>keywords
            </ul>
            <li class="fragment">Deferrable (needed for self-hosting):
            <ul>
              <li>step 5 / TCO
              <li>vectors and hash-maps
              <li>reader macros, comments
            </ul>

          </ul>
          <aside class="notes">
            <ul>
              <li>Some things are completely optional like Tail-Call
              Optimization (step 5) and Clojure-style keywords.
              <li>Many others things can be deferred to later steps
              but are needed for full self-hosting.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Coaching</h2>
          <ul>
            <li class="fragment">Step-by-step guide at
            <a
                href="https://github.com/kanaka/mal/blob/master/process/guide.md">blob/master/process/guide.md</a>
            <ul>
                <li>Logical feature diagram for each step:<br> e.g. <a
                    href="https://github.com/kanaka/mal/blob/master/process/guide.md#step0">step0</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step1">step1</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step2">step2</a>
            </ul>
            <li class="fragment">Psuedo-code for each step
            <li class="fragment">FAQ at <a href="https://github.com/kanaka/mal/blob/master/docs/FAQ.md">blob/master/docs/FAQ.md</a>
            <li class="fragment"><span style="color: green">#mal</span> channel on freenode
          </ul>
          <aside class="notes">
            <ul>
              <li><span class="next">Step-by-step guide is the main
                coaching tool.
              <li><span class="next">SHOW PAGES (turn head)</span>
              <li><span class="next">&gt;&gt;</span> Psuedo-code that
              you can diff to see what the difference between steps
              is.
              <li><span class="next">&gt;&gt;</span> FAQ: explains why
              steps are structured the way they are and what form your
              implementation needs to take to get accepted into
              repository.
              <li><span class="next">&gt;&gt;</span> <span
              style="color: green">#mal</span>: interested
              in any aspect of mal, please join channel.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Feedback</h2>
          <ul>
            <li class="fragment">Measuring change over time
            <li class="fragment">Frequent feedback
            <li class="fragment">In make-a-lisp feedback works like
            this:
            <pre><code class="bash" data-trim contenteditable>
make test^MY_IMPL
</code></pre>
            <li class="fragment">Or:
            <pre><code class="bash" data-trim contenteditable>
make test^MY_IMPL^stepX
</code></pre>
          </ul>
          <aside class="notes">
            <ul>
              <li>[Read through slide]
            </ul>
          </aside>
        </section>

        <section>
          <h2>Game Overview (Turns)</h2>
          <ul>
            <li class="fragment">For each step:
            <ol>
              <li class="fragment">Choose a step task
              <li class="fragment">Google, stackoverflow, references, tutorials
              <li class="fragment">Implement/tweak until tests pass
              <li class="fragment">Repeat until step is done
            </ol>
          </ul>
          <aside class="notes">
            <ul>
              <li>Reminder <span class="next" id="reminder">SLIDES visible?</span>
              <li>Based on Guide, or Pseudo-code, or
              test (TDD), pick a feature/functionality of current step
              <li>Google, stackoverflow
              <li>Iterate between 2 &amp; 3
            </ul>
          </aside>
        </section>

        <section>
          <h2>Let's Play</h2>
          <ul>
            <li class="fragment">Round one
          </ul>
          <aside class="notes">
            <ul>
              <li><span class="next">&gt;&gt;</span> Now I'm going to
              show you round one of this game.
              <li><span class="next">SWITCH</span>
              <li>Update Makefile with 3 foo changes
              <li>Stubs for the read/eval/print parts of REPL
              <li>Lookup up python input on stackoverflow
              <li>Broken output
              <li>Show test file
              <li>Run test
              <li>Explain test counts and the output format
              <li>Fix output
              <li>Show test again
              <li><span class="next">SWITCH BACK</span>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Your Turn!</h2>
          <ul>
            <li>Learn a new language using mal
            <li>Create an new implementation
            <li>Improve the game
            <li>Improve an existing implementation
            <li>Do some language research with mal implementations
            <li>Make a cool logo for mal
          </ul>
          <aside class="notes">
            <ul>
              <li>Learn a new language using mal
              <li>Create an new implementation:
              <li>Improve the game
              <li>Improve an existing implementation: e.g. Haskell
              <li>Do some research using existing mal implementations
              <li>If you're more design inclined, a logo for mal.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Questions</h2>
        </section>

        <section>
          <h2>References</h2>
          <ul>
            <li><a href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a>
            <li><a href="https://github.com/kanaka/midwest.io.mal">https://github.com/kanaka/midwest.io.mal</a>
            <li><span style="color: green">#mal</span> (freenode)
            <li><a href="http://twitter.com/buskanaka">@buskanaka</a>
            <li><a href="viasat.com">viasat.com</a>
          </ul>
        </section>

        <section>
          <h2>Extra Material</h2>
        </section>

        <section data-background="#ffffff">
          <img src="media/language_graph.png"
               width="70%" style="box-shadow: none;"></img>
        </section>

        <section>
          <h2>New Implementation Ideas</h2>
          <font size=5em>
          <span style="padding: 50px">
          <ul>
            <li>Something old
            <ul>
              <li>Fortran
              <li>COBOL
              <li>Pascal
              <li>Ada
              <li>Assembly
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something new
            <ul>
              <li>Idris
              <li>Io
              <li>Dart
              <li>Elm
              <li>TypeScript
            </ul>
          </ul>
          </span>

          <br><br>

          <span style="padding: 50px">
          <ul>
            <li>Something borrowed<br>(from another domain)
            <ul>
              <li>TeX
              <li>PL/SQL
              <li>Prolog
              <li>Verilog / VHDL
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something blue<br>(corporate/government)
            <ul>
              <li>Objective-C
              <li>PowerShell
              <li>ColdFusion
              <li>MUMPS (OpenM)
            </ul>
          </ul>
          </font>
          </span>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
